import ws from 'ws'

// Quoted especial con estÃ©tica KARBOT
async function makeFkontak() {
    try {
        const thumb2 = Buffer.alloc(0)
        return {
            key: { 
                participants: '0@s.whatsapp.net', 
                remoteJid: 'status@broadcast', 
                fromMe: false, 
                id: 'KarBotList' 
            },
            message: { 
                locationMessage: { 
                    name: 'ğŸ“‹ ğ™»ğ™¸ğš‚ğšƒğ™° ğ™³ğ™´ ğš‚ğš„ğ™±ğ™±ğ™¾ğšƒğš‚', 
                    jpegThumbnail: thumb2 
                } 
            },
            participant: '0@s.whatsapp.net'
        }
    } catch { return undefined }
}

function dhms(ms) {
    const segundos = Math.floor(ms / 1000);
    const minutos = Math.floor(segundos / 60);
    const horas = Math.floor(minutos / 60);
    const dÃ­as = Math.floor(horas / 24);

    const s = segundos % 60;
    const m = minutos % 60;
    const h = horas % 24;

    let resultado = "";
    if (dÃ­as !== 0) resultado += dÃ­as + 'd '
    if (h !== 0) resultado += h + 'h '
    if (m !== 0) resultado += m + 'm '
    if (s !== 0) resultado += s + 's'
    return resultado || "0s";
}

// Nueva funciÃ³n para verificar conexiÃ³n real
function isSubbotActive(subbot) {
    if (!subbot || !subbot.user) return false;
    
    // MÃ©todo 1: Verificar si el socket estÃ¡ definido y en estado OPEN
    if (subbot.ws) {
        return subbot.ws.readyState === ws.OPEN;
    }
    
    // MÃ©todo 2: Verificar si hay un objeto de conexiÃ³n con estado
    if (subbot.connection) {
        return subbot.connection === 'open';
    }
    
    // MÃ©todo 3: Verificar si tiene credenciales vÃ¡lidas y estÃ¡ marcado como activo
    if (subbot.user && subbot.user.id) {
        return true; // Asumir activo si tiene usuario
    }
    
    return false;
}

// FunciÃ³n para obtener nÃºmero de telÃ©fono si estÃ¡ disponible
function getSubbotPhoneNumber(subbot) {
    if (!subbot || !subbot.user) return "Desconocido";
    
    try {
        // Intentar extraer de diferentes formas
        if (subbot.user.jid) {
            // Formato: 123456789@s.whatsapp.net
            const phone = subbot.user.jid.split('@')[0];
            if (phone && phone.length >= 7) {
                return `+${phone}`;
            }
        }
        
        if (subbot.user.id) {
            // A veces el ID es el nÃºmero directamente
            const id = subbot.user.id.toString();
            if (id.includes('@s.whatsapp.net')) {
                return `+${id.split('@')[0]}`;
            }
            // Si parece un nÃºmero de telÃ©fono
            if (/^\d+$/.test(id) && id.length >= 7) {
                return `+${id}`;
            }
        }
        
        return "Desconocido";
    } catch {
        return "Desconocido";
    }
}

let handler = async(m, { usedPrefix, conn, text }) => {
    // ReacciÃ³n inicial
    try { await conn.sendMessage(m.chat, { react: { text: 'ğŸ”', key: m.key } }) } catch {}
    
    // Obtener subbots usando la nueva funciÃ³n de verificaciÃ³n
    const activeSubbots = [];
    const inactiveButValid = [];
    
    if (global.subbots && Array.isArray(global.subbots)) {
        for (const subbot of global.subbots) {
            if (isSubbotActive(subbot)) {
                activeSubbots.push(subbot);
            } else if (subbot.user && subbot.id) {
                // Tiene credenciales pero no estÃ¡ conectado actualmente
                inactiveButValid.push(subbot);
            }
        }
    }
    
    const totalActive = activeSubbots.length;
    const totalWithCredentials = activeSubbots.length + inactiveButValid.length;
    
    // Contar sesiones guardadas
    async function countSavedSessions() {
        try {
            const fs = await import('fs/promises');
            const path = await import('path');
            
            const sessionsDir = 'Sessions/SubBot';
            try {
                await fs.access(sessionsDir);
            } catch {
                return 0;
            }
            
            const items = await fs.readdir(sessionsDir);
            let sessionCount = 0;
            
            for (const item of items) {
                try {
                    const itemPath = path.join(sessionsDir, item);
                    const stats = await fs.stat(itemPath);
                    
                    if (stats.isDirectory()) {
                        // Verificar si tiene creds.json vÃ¡lido
                        const credsPath = path.join(itemPath, 'creds.json');
                        try {
                            await fs.access(credsPath);
                            const credsStats = await fs.stat(credsPath);
                            if (credsStats.size > 100) { // MÃ¡s de 100 bytes = vÃ¡lido
                                sessionCount++;
                            }
                        } catch {
                            // No tiene creds.json o es invÃ¡lido
                        }
                    }
                } catch {
                    continue;
                }
            }
            
            return sessionCount;
        } catch (error) {
            console.error('Error contando sesiones:', error);
            return 0;
        }
    }
    
    const sesionesGuardadas = await countSavedSessions();
    
    // Construir mensaje
    let cap = `â•­â”â”ã€” ğŸ“Š *ğš‚ğšƒğ™°ğšƒğš„ğš‚ ğš‚ğš„ğ™±ğ™±ğ™¾ğšƒğš‚* ã€•â”â”â¬£\n`;
    cap += `â”ƒ\n`;
    cap += `â”ƒ ğŸ’¾ ğš‚ğ™´ğš‚ğ™¸ğ™¾ğ™½ğ™´ğš‚ ğ™¶ğš„ğ™°ğšğ™³ğ™°ğ™³ğ™°ğš‚: ${sesionesGuardadas}\n`;
    cap += `â”ƒ ğŸŸ¢ ğš‚ğ™´ğš‚ğ™¸ğ™¾ğ™½ğ™´ğš‚ ğ™°ğ™²ğšƒğ™¸ğš…ğ™°ğš‚: ${totalActive}/100\n`;
    cap += `â”ƒ ğŸ“ ğš‚ğ™´ğš‚ğ™¸ğ™¾ğ™½ğ™´ğš‚ ğš…Ãğ™»ğ™¸ğ™³ğ™°ğš‚: ${totalWithCredentials}\n`;
    cap += `â”ƒ\n`;
    cap += `â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£\n\n`;
    
    // Listar subbots activos
    if (totalActive > 0) {
        cap += `*ğŸŸ¢ ğš‚ğš„ğ™±ğ™±ğ™¾ğšƒğš‚ ğ™°ğ™²ğšƒğ™¸ğš…ğ™¾ğš‚:*\n`;
        
        activeSubbots.forEach((subbot, index) => {
            const phoneNumber = getSubbotPhoneNumber(subbot);
            const name = subbot.user?.name || `Sub-Bot ${index + 1}`;
            const uptime = subbot.uptime ? dhms(Date.now() - subbot.uptime) : "ReciÃ©n activo";
            const id = subbot.id || subbot.user?.id?.split('@')[0] || "Desconocido";
            
            cap += `*${index + 1}.* ğŸ¤– *${name}*\n`;
            cap += `> ğŸ“± *ğ™½ğš„ğ™¼ğ™´ğšğ™¾:* ${phoneNumber}\n`;
            cap += `> â±ï¸ *ğš„ğ™¿ğšƒğ™¸ğ™¼ğ™´:* ${uptime}\n`;
            cap += `> ğŸ”— *ğ™¸ğ™³:* ${id}\n`;
            cap += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
        });
    } else {
        cap += `> ğŸ“­ *ğ™½ğ™¾ ğ™·ğ™°ğšˆ ğš‚ğš„ğ™±ğ™±ğ™¾ğšƒğš‚ ğ™°ğ™²ğšƒğ™¸ğš…ğ™¾ğš‚ ğ™´ğ™½ ğ™´ğš‚ğšƒğ™´ ğ™¼ğ™¾ğ™¼ğ™´ğ™½ğšƒğ™¾*\n\n`;
    }
    
    // Listar sesiones vÃ¡lidas pero no activas
    if (inactiveButValid.length > 0) {
        cap += `*ğŸŸ¡ ğš‚ğ™´ğš‚ğ™¸ğ™¾ğ™½ğ™´ğš‚ ğ™³ğ™¸ğš‚ğ™¿ğ™¾ğ™½ğ™¸ğ™±ğ™»ğ™´ğš‚ (ğš„ğš‚ğ™°ğš .ğš›ğšğšŒğš˜ğš—ğšğšŒğšğšŠğš›):*\n`;
        
        inactiveButValid.forEach((subbot, index) => {
            const phoneNumber = getSubbotPhoneNumber(subbot);
            const id = subbot.id || "Desconocido";
            
            cap += `*${index + 1}.* ğŸ’¾ *ğ™¸ğ™³:* ${id}\n`;
            cap += `> ğŸ“± *ğ™½ğš„ğ™¼ğ™´ğšğ™¾:* ${phoneNumber}\n`;
            cap += `> âš ï¸ *ğ™´ğš‚ğšƒğ™°ğ™³ğ™¾:* SesiÃ³n guardada (no conectada)\n`;
            cap += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
        });
    }
    
    // Consejo de reconexiÃ³n
    if (inactiveButValid.length > 0) {
        cap += `\nğŸ’¡ *ğšƒğ™¸ğ™¿:* Usa *${usedPrefix}reconectar <id>* para reactivar sesiones guardadas\n`;
        cap += `   Ejemplo: *${usedPrefix}reconectar ${inactiveButValid[0]?.id || "usuario"}*\n`;
    }
    
    const fkontak = await makeFkontak();
    const mentions = activeSubbots
        .map(subbot => subbot.user?.jid)
        .filter(jid => jid && jid.includes('@s.whatsapp.net'));
    
    try {
        await conn.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
        await conn.sendMessage(m.chat, {
            text: cap.trim(), 
            mentions: mentions,
        }, { quoted: fkontak || m });
        
    } catch (e) {
        console.error('Error enviando mensaje:', e);
        // Fallback simple
        try {
            await conn.reply(m.chat, cap.trim(), m);
        } catch (e2) {
            console.error('Error en fallback:', e2);
        }
    }
}

handler.help = ['botlist'];
handler.tags = ['serbot'];
handler.command = ['bots', 'listabots', 'subbots', 'statusbots']; 

export default handler;